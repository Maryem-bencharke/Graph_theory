# -*- coding: utf-8 -*-
"""Huffman_coding.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1rvzt1owj-V3IWY2f2zbYrz4PeJKrDqjb

<hr />
<H1 align="center"><FONT COLOR=red> <U>Huffman Coding</U></H1>
 <hr />

Huffman coding is a widely used method in data compression. It is used to encode a sequence of characters in binary, using a variable number of bits for each character depending on how often the character occurs. Huffman's idea is to identify the most frequent characters and assign them short codes, while the less frequent characters will have longer codes.

<FONT size="4pt"> <FONT color="red">I)  <U>Sorting the frequencies</U></FONT></FONT>

<FONT size="2pt">We can define a binary tree in such a way that each node is represented by both a character and a frequency using this class : </FONT>
"""

class Tree:
    def __init__(self, char,freq):
        self.data=(char,freq)
        self.left = None
        self.right = None
    def __str__(self):
        return "["+str(self.data)+",["+str(self.left)+","+str(self.right)+ "]"+  "]"

"""<hr />
<FONT size="2pt"><U> <FONT color="blue"> Q1) Using merge sort, Write a function sort(L), which takes a list of characters L as a parameter and returns the associated list of trees sorted in ascending order of frequencies</FONT></U>
</FONT>
<br>   <br>     
 <FONT size="2pt"> <FONT color="green"> <U>Example</U> :</FONT>
 <br>
By printing the elements of sort(['C','A','S','A','B','L','N','C','A']) you'll obtain : <br>
[('N', 1),[None,None]]<br>
[('L', 1),[None,None]]<br>
[('B', 1),[None,None]]<br>
[('S', 1),[None,None]]<br>
[('C', 2),[None,None]]<br>
[('A', 3),[None,None]]
 <hr />

<U>Illustration of the merge sort algorithm</U> :
<img src="./images/TRI.png" width="500" height="500" />
"""

def merge(left, right):
    result = []
    i = j = 0

    while i < len(left) and j < len(right):
        if left[i].data[1] < right[j].data[1]:
            result.append(left[i])
            i += 1
        else:
            result.append(right[j])
            j += 1

    result.extend(left[i:])
    result.extend(right[j:])
    return result

def merge_sort(L):
    if len(L) <= 1:
        return L

    mid = len(L) // 2
    left = L[:mid]
    right = L[mid:]

    left = merge_sort(left)
    right = merge_sort(right)

    return merge(left, right)

def sort(L):
    char_freq = {}
    for char in L:
        if char in char_freq:
            char_freq[char] += 1
        else:
            char_freq[char] = 1

    tree_list = [Tree(char, freq) for char, freq in char_freq.items()]
    sorted_tree_list = merge_sort(tree_list)

    return sorted_tree_list

char_list = ['C', 'A', 'S', 'A', 'B', 'L', 'N', 'C', 'A']
sorted_tree_list = sort(char_list)

for tree in sorted_tree_list:
    print(tree)

"""<FONT size="4pt"> <FONT color="red">II)  <U>Creation of the Huffman binary tree</U></FONT></FONT>

The Huffman binary tree is created using the following process:

<ul>
  <li>Creating the sorted list of trees in ascending order of frequencies.</li>
  <li>As long as the list contains at least two elements, repeat the following steps :
    <ul>
  <li>Remove the first two elements whose frequencies are the smallest and create a tree with a frequency equal to the sum of the frequencies of these two elements.</li>
  <li>Insert the obtained tree into the list of trees in such a way that it remains in ascending order of frequencies.</li>
</ul>
    </li>
</ul>






The leaves of the resulting binary tree are the different elements of the list to be compressed.

<br>    
<U> <FONT color="green">Example:</FONT></U>
<img src="./images/Huffman_tree.png" width="500" height="500" />

<hr /><FONT size="2pt"><U> <FONT color="blue"> Q2) Write the function: huffmanTree(L), which takes as a parameter a list of characters L. The function returns a Huffman binary tree created according to the principle described above.</FONT></U>
  <br> <br> <hr />
"""

def huffmanTree(L):
    char_freq = {}
    for char in L:
        if char in char_freq:
            char_freq[char] += 1
        else:
            char_freq[char] = 1

    tree_list = [Tree(char, freq) for char, freq in char_freq.items()]
    tree_list.sort(key=lambda x: x.data[1])

    while len(tree_list) > 1:
        left_tree = tree_list.pop(0)
        right_tree = tree_list.pop(0)

        combined_freq = left_tree.data[1] + right_tree.data[1]
        combined_tree = Tree(None, combined_freq)
        combined_tree.left = left_tree
        combined_tree.right = right_tree

        insert_index = 0
        while insert_index < len(tree_list) and tree_list[insert_index].data[1] < combined_freq:
            insert_index += 1
        tree_list.insert(insert_index, combined_tree)

    return tree_list[0]

char_list = ['C', 'A', 'S', 'A', 'B', 'L', 'N', 'C', 'A']
huffman_tree = huffmanTree(char_list)
print(huffmanTree(char_list))

"""<FONT size="4pt"> <FONT color="red">III)  <U>Building Huffman trees dictionaries</U></FONT></FONT>

Once the Huffman Tree is obtained, the next step is to build a dictionary where the keys are the different elements of the str to compress (the character values associated with the leaf nodes of the Huffman binary tree), and the values are the corresponding Huffman binary codes.

We associate the code 0 with each left branch and the code 1 with each right branch. To obtain the binary code of each leaf, we traverse the tree from the root to the leaves, adding 0 or 1 to the code each time, depending on the branch taken.
<br>
<img src="./images/bin.png" width="250" height="250" />
<br><br>
When traversing the above tree, we obtain the following codes :<br>
<img src="./images/table.png" width="200" height="200" />

<hr /><FONT size="2pt"><U> <FONT color="blue"> Q3) Write the function dict_Huffman(T,code,dict), which takes three parameters:</U>
    
  <ul>
  <li> T : is a Huffman binary tree, created following the principle of the previous question.
  <li>code : is a string containing the prefix of the subtrees of T, it is initialized with :  ' ',
    <li>dict :  is a dictionary initialized with :  { }
</ul>  
   <FONT color="blue"> The function traverses the tree, adding to the dict dictionary, the values associated with the tree's leaves as keys and their corresponding binary codes as values.</FONT> <br> <br>
    <U> <FONT color="green">Example:</FONT></U>  <br>
    code=''<br>
dict={}<br>
dict_Huffman(huffmanTree(['M','A','H','A','M','A']),code,dict)<br>
print(dict)<br>
{'A': '0', 'H': '10', 'M': '11'}<br>
<hr />
"""

def dict_Huffman(T, code, code_dict):
    if T.data[0] is not None:
        char, _ = T.data
        code_dict[char] = code
    else:
        if T.left:
            dict_Huffman(T.right, code + '0', code_dict)
        if T.right:
            dict_Huffman(T.left, code + '1', code_dict)

code = ''
code_dict = {}
char_list = ['M', 'A', 'H', 'A', 'M', 'A']
huffman_tree = huffmanTree(char_list)
dict_Huffman(huffman_tree, code, code_dict)
print(code_dict)

"""<FONT size="4pt"> <FONT color="red">IV)  <U>Huffman Compression and Decompression </U></FONT></FONT>

The binary code dictionary holds the elements of the character string to be compressed, along with their corresponding Huffman binary codes. We can now proceed to compress the character string.

<hr /><FONT size="2pt"><U> <FONT color="blue"> Q4) Write the function compress(S, dict) that takes the character string S and the dictionary dict of Huffman binary codes as parameters. The function returns a character string containing the concatenation of the Huffman binary codes corresponding to each element of S.</U>
    <br> <br>
    <U> <FONT color="green">Example:</FONT></U>  <br>
    compress('MAHAMA' , {'A': '0', 'H': '10', 'M': '11'})
<br>
'110100110'
<br>
<hr />
"""

def compress(S, code_dict):
    compressed_string = ""

    for char in S:
        if char in code_dict:
            compressed_string += code_dict[char]
        else:
            raise ValueError(f"Character '{char}' not found in the Huffman dictionary")

    return compressed_string

huffman_dict = {'C': '00', 'N': '010', 'L': '011', 'B': '100', 'S': '101', 'A': '11'}
compressed = compress('CASABLNCA', huffman_dict)
print(compressed)

"""<hr />
The decompression process aims to recover the original character string using the binary string and the code dictionary.

<hr /><FONT size="2pt"><U> <FONT color="blue"> Q5) Write the function decompress(dict, B) that takes the Huffman code dictionary dict and the binary character string B as parameters. The function returns the original character string</U>
    <br> <br>
    <U> <FONT color="green">Example:</FONT></U>  <br>
    decompress({'A': '0', 'H': '10', 'M': '11'},'110100110')
<br>
'MAHAMA'
<br>
<hr />
"""

def decompress(code_dict, B):
    reversed_dict = {v: k for k, v in code_dict.items()}

    decoded_string = ""
    current_code = ""

    for bit in B:
        current_code += bit
        if current_code in reversed_dict:
            decoded_string += reversed_dict[current_code]
            current_code = ""

    return decoded_string


huffman_dict = {'C': '00', 'N': '010', 'L': '011', 'B': '100', 'S': '101', 'A': '11'}
compressed = '0011101111000110100011'
decompressed = decompress(huffman_dict, compressed)
print(decompressed)

"""<FONT size="4pt"> <FONT color="red">V)  <U>Example </U></FONT></FONT>

<hr /><FONT size="2pt"><U> <FONT color="blue"> Q6) Using Huffman Coding, compress this text:</U>
    <br>
Huffman coding is a popular algorithm used for lossless data compression. It was developed by David A. Huffman while he was a Ph.D. student at MIT and was published in 1952. The primary goal of Huffman coding is to compress data efficiently by assigning shorter codes to more frequent symbols or characters and longer codes to less frequent ones. <hr />
"""

def generate_huffman_codes(tree, code, code_dict):
    if tree.data[0] is not None:
        char, _ = tree.data
        code_dict[char] = code
    if tree.left:
        generate_huffman_codes(tree.left, code + '0', code_dict)
    if tree.right:
        generate_huffman_codes(tree.right, code + '1', code_dict)

input_text = "Huffman coding is a popular algorithm used for lossless data compression. It was developed by David A. Huffman while he was a Ph.D. student at MIT and was published in 1952. The primary goal of Huffman coding is to compress data efficiently by assigning shorter codes to more frequent symbols or characters and longer codes to less frequent ones."

huffman_tree = huffmanTree(input_text)

huffman_code_dict = {}
generate_huffman_codes(huffman_tree, '', huffman_code_dict)

compressed_text = ''
for char in input_text:
    compressed_text += huffman_code_dict[char]

print(compressed_text)

""" <hr /><FONT size="2pt"><U> <FONT color="blue"> Q7) Using Huffman Coding, decompress the huffman code of the previous text and check that it is indeed the original text</U>
    <br>
 <hr />
"""

def decompress_text(compressed_text, code_dict):
    reversed_dict = {v: k for k, v in code_dict.items()}
    decoded_text = ""
    current_code = ""

    for bit in compressed_text:
        current_code += bit
        if current_code in reversed_dict:
            decoded_text += reversed_dict[current_code]
            current_code = ""

    return decoded_text

decompressed_text = decompress_text(compressed_text, huffman_code_dict)

if decompressed_text == input_text:
    print("Decompression successful. The original text is:", decompressed_text)
else:
    print("Decompression failed. The texts do not match.")

"""<FONT size="4pt"> <FONT color="red">VI)  <U>Huffman code Vs Ascii Code</U></FONT></FONT>

The ASCII code (American Standard Code for Information Interchange) is a character encoding standard used for representing text and control characters in computers and communication equipment. In ASCII, each character is assigned a unique numeric value, which is represented as a 7-bit binary number in the 128-character version.
<br><br>
Here are some common ASCII codes for a few characters :
<ul>
  <li>The ASCII code for the letter 'A' is 65 in decimal or 1000001 in binary.</li>
  <li>The ASCII code for the digit '0' is 48 in decimal or 0110000 in binary.</li>
  <li>The ASCII code for the space character ' ' (blank) is 32 in decimal or 0100000 in binary.</li>
</ul>
<img src="./images/ascii.png" width="500" height="500" />

<hr />
We obtain the ASCII binary code associated with a string by using the following function :
"""

import math
def toBinary(a):
    binary_str = ""
    for i in a:
        binary_char = bin(ord(i))[2:]

        binary_char = "0" * (7 - len(binary_char)) + binary_char
        binary_str += binary_char
    return binary_str

print(toBinary(' '))

"""

<hr /><FONT size="2pt"><U> <FONT color="blue"> Q8) Compare the sizes of the Huffman code and the ASCII code for the text from the previous example.
</U>
    <br> <br>
 <hr />
"""

ascii_binary_text = toBinary(input_text)
ascii_size = len(ascii_binary_text)

huffman_size = len(compressed_text)

print("Size of ASCII code:", ascii_size, "bits")
print("Size of Huffman code:", huffman_size, "bits")

if huffman_size < ascii_size:
    print("Huffman code is more space-efficient.")
elif huffman_size > ascii_size:
    print("ASCII code is more space-efficient.")
else:
    print("Huffman code and ASCII code are the same size.")

""" <hr />
We randomly select an element from the set of lowercase alphabets as follows:
"""

import string
import random
all_characters = string.ascii_lowercase
rd=random.choice(all_characters)
print(rd)

""" <hr /><FONT size="2pt"><U> <FONT color="blue"> Q9) Create a list that contains 1000 lists, each of size 100, of random lowercase alphabets. Subsequently, construct a list L1 which store the corresponding Huffman codes for each of these sublists. Following that, create a list that contains the ratios of the lengths of elements in L1 and the lengths of the corresponding binary ASCII codes. Finally, calculate and return the average of this list.
</U>
    <br>
 <hr />

"""

random_lists = [
    [random.choice(string.ascii_lowercase) for _ in range(100)] for _ in range(1000)
]


huffman_codes = []
ascii_lengths = []

for sublist in random_lists:
    huffman_tree = huffmanTree(sublist)

    huffman_code_dict = {}
    generate_huffman_codes(huffman_tree, '', huffman_code_dict)

    compressed_text = ""
    for char in sublist:
        compressed_text += huffman_code_dict[char]

    ascii_binary_text = toBinary("".join(sublist))

    huffman_codes.append(compressed_text)
    ascii_lengths.append(len(ascii_binary_text))

ratios = [len(huffman_code) / ascii_length for huffman_code, ascii_length in zip(huffman_codes, ascii_lengths)]

average_ratio = sum(ratios) / len(ratios)
print("Average Ratio:", average_ratio)